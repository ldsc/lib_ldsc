===============================================================================
libldsc
===============================================================================
Nome deste arquivo: 	TODO
Conteudo:		Lista das tarefas a serem realizadas.
Autor:			André Duarte Bueno, Leando Puerari.

===============================================================================
Outros arquivos de ajuda
===============================================================================
README		Descreve o que é a libldsc e os arquivos de ajuda.
INSTALL		Descreve como instalar a libldsc.
HOWTO		Descreve como utilizar a libldsc.
NEWS		Descreve as novidades das últimas versões.
ORGANIZATION	Descreve como modificar a libldsc 
		(informaçoes para desenvolvedores - programadores).
TODO		Lista das tarefas a serem realizadas.
BUGS		Lista de bugs relatados ou identificados.
ChangeLog	Lista de modificaçoes da biblioteca.
COPYING		Descreve as condições para cópia e instalação da libldsc
		e a licença pública da GNU (Versão 2).
AUTHORS		Lista dos autores da libldsc.

===============================================================================

\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
                               TODO-> feature grafoconexaoserial
\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
[Específico feature->atualizacao_grafo_conexão_serial]
======================================================
PASSO_1: REORGANIZAR OBJETOS E GRAFO
[X] - Reorganizar hierarquia de objetos do grafo:  
CObjetosGrafo     (rotulo)
CObjetosRede      (propriedade,  conexao,  condutancia)
CObjetosEsqueleto ( cx, cy, cz)
[X] - Renomear diversas variáveis e funções.
[X] - Criar enumeração TipoGrafo e função Tipo,  que retorna o tipo de objeto.

[X] - Criar CBaseGrafoRedeEsqueleto; 
[X] - Criar CGrafo (Cria vetor CObjetoGrafo*) 
[X] - Criar CRede  (Cria vetor CObjetoRede*)
[X] - Renomear CGrafo_3dBy2D para CGrafoConexaoSerial as demais para CGrafoConexaoSerial_M1..
Manter o nome grafo pois foi o usado na tese.
[X] - Revisar os códigos e comentários do GrafoConexaoSerial;
[] - Fazer funcionar ! ! ! não esta executando Go dos objetos do grafo,
verificar se Solver esta chamando corretamente os objetos.

[]- Fazer deletado = numeric_limits<unsigned int>::max(); evitando problema com objeto.size()!
[X]- Testar com calma EliminarRamosMortos(1) pois esta provocando falha de segmentação!
ok, problema era no CRedeEsqueleto que estava criando somente objetos centro, todos eram deletados por EliminarRamosMortos!
Note que a versão para Eneida, isto é, antes de reestruturas os códigos, estava funcionando!
[X]- Testar com calma EliminaRamosMortos(2) pois esta apagando partes válidas da imagem! não deveria ler objetos dos planos z=0 e z=n-1!
Note que a versão para Eneida, isto é, antes de reestruturas os códigos, estava funcionando!
ok, problema era no CRedeEsqueleto que estava criando somente objetos centro, todos eram deletados por EliminarRamosMortos!
Note que a versão para Eneida, isto é, antes de reestruturas os códigos, estava funcionando!
[X] - Reorganizar estrutura diretorios
/EstruturaDados
/EstruturaDados/Grafo
/EstruturaDados/Rede
/EstruturaDados/Esqueleto
[X] - Criar libldsc_app
[ ] - Reorganizar libldsc_app; cada subdiretório deve ser uma aplicação?
[ ] - Criar .

Passo_2: OTIMIZAR_VELOCIDADE_PROCESSAMENTO
[X] - Criar classe CObjetoRede_Tipo e CObjetosEsqueleto_Tipo sem métodos virtuais (otimização).
[X] - Criar #define OTIMIZAR_VELOCIDADE_PROCESSAMENTO
Use OTIMIZAR_VELOCIDADE_PROCESSAMENTO para criar CObjetoRede_Tipo que é + rápido.
[] - Criar classe CObjetoRede_Final e CObjetosEsqueleto_Final com uso de final de C++11.
[] - Comparar desempenho:
Usando objetos virtuais    (é o processamento normal)
Usando objeto Final (uso de final de C++11)
Usando objeto Tipo (não virtual); uso de OTIMIZAR_VELOCIDADE_PROCESSAMENTO

Passo_3: MUDAR SOLVER
[ ] - Usar solver de boost

Passo_4: USAR TEMPLATE
[ ] - Modificar hierarquia objetos
[ ] - Modificar hierarquia grafos
[] - Comparar desempenho:

Passo_5:
[x]- No modelo M1 adicionar flag que ativa chamada eliminação das condutâncias em paralelo.
[ ]- Tarefa: testar ativação deste flag e resultados para modelo 1.
Jogar saidas na tela;
[]- Tirar acesso public das propriedades rotulo,  condutância...
[]- Desenvolver modelo M3b que considera píxeis vizinhos a area de interseccao.
Plano
---------------------------------------------------------
---1111111111X3333X11111111-----1111111111111-----------
---1111111111X3333X11111111-----1111111111111-----------
---1111111111X3333X11111111-----1111111111111-----------
---------------------------------------------------------
Corte ->atual
-----------11111111111111-----------ra
--------------xxxxxx----------------rotint
--------------222222----------------rp
Corte ->novo
-----------11111111111111-----------ra
-------------AxxxxxxA---------------rotint adiciona 1/2 píxel A
--------------222222----------------rp

[] - Desenvolver modelo M9, considera IDF 
3D.
[] - Trocar o valor de "deletado" que deve ser numeric_limits<>max()
[] - Corrigir códigos como:
         sitio = dynamic_cast < CObjetoEsqueleto* > ( objeto[k] );
         assert ( sitio );
lanca excecao antes do assert !
[] - Criar novo diretório CGrafoOtimizado,  em que os objetos rede e esqueleto não terão 
métodos virtuais (pode ter herança).
[] - Em CObjetoRede::Go CObjetoRede_Final CObjetoRede_Tipo::Go 
testar desempenho com e sem o static; como o compilador usa opções de
	/// otimização é possível que sem estáticstatic fique mais rápido!
[] - Em CObjetoRede::Go só considera sítios vizinhos no calculo do novo x;
[] - Testar:
   virtual bool CGrafo::DeletarObjeto ( CObjetoGrafo* objeto_i ) override {
      delete objeto_i;
      int posicao_i = objeto_i - *objeto.data();
      objeto.erase ( objeto.begin() + posicao_i );
   }
[]- Melhorar resumo git, Acrescentar dicas de git.org.cz "Git Cheat Sheet"
[] - Ver livro que fala de padrões de projeto, classe padrão para criar objetos.
[] - 

[] - Controle acesso,  colocar protected: e friend para CGrafo CPermeabilidadeGrafo
[] - @todo: trocar assert? usar static_assert de C++11! ou try..catch?
[] - Transformar Vector em template.
[] - Sobrecarregar operador << ??; 
[] - Implementar versão que recebe uma ostream. 
Ex: grafo->Write();    //  Usa nome arquivo para salvar grafo
Ex: grafo->Write(fout);//  Salva grafo em fout
Ex: fout << grafo;     // Sobrecarga
[] - renomear Write -> Salvar; ex: grafo->Salvar();
[] - renomear Read  -> Ler; ex: grafo->Ler();
    @todo: transformar CVetor em template!
[] trocar unsigned int por uint32_t
[] -   @todo:    Criar classes 
  CReta -> CReta(a,b); Calcula y = Go(x); Calcula y = Go(x,a,b);
  CSegmentoReta (prova c++)
  using CEstimativaValorBaseadaValorContorno = CSegmentoReta;
  no grafo substituir CContornoCentro por CContorno, e
  usar criar CEstimativaValorBaseadaValorContorno.
??  
long double EstimativaValorBaseadaValorContorno(long double a,long double b){}
[] - Transformar
bool CGrafoTest::ProcessarListaImagens ( unsigned int argc, char* argv[] )
bool CGrafoTest::Permeabilidade_By_ModelX_Decisao ( string nomeArquivo, int modelo, TCMatriz3D<int>* pm3D, ofstream& fout 
num modelo para qualquer tipo processamento arquivos.
[] - Criar padrão para arquivos com dados objetos.
* @todo: como padrão de modelagem, seria interessante ter duas possibilidades; 
 * i) Por padrão os dados de cada objeto são armazenados em arquivos de disco, isto é, 
 * para cada objeto um arquivo de disco.
 * ii) Possibilidade de ter todos os dados num único arquivo de disco com formato genérico:
 * [objeto]
 * 	Propriedade1 = valor
 * 	Propriedade2 = valor
 * uma função auxiliar verificaria a existência dos arquivos individuais e do arquivo genérico
 * e, em função do padrão definido pelo usuário leria um ou outro arquivo.
[] - Tipos de erro.
 * @todo: Toda simulação tem erros, portanto, seria interessante adicionar aqui um objeto de erro;
 * inicialmente pode ser uma variável long double para indicar o erro associado; depois, pensar em criar
 * uma hierarquia de objetos do tipo CTipoErro e uma enumeção ETipoErro.
 * Dar uma olhada em bibliotecas da gnu e boost, para ver como tratam este tipo de problema.

\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
                               TODO-> TESE ALUNOS
\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
[Específico tese Leandro]
=======================================
Objetivo: A ideia é resolver questões associadas diretamente a tese do 
Leandro, usando códigos existentes.
O Leandro fica com controle do branch master até terminar sua tese.

[] - Gerar pacote da versao (1.5 que funcione redondinho com lvp) e arquivar em libs.
Será a ultima versao com estrutura de diretórios antiga.
Gerar a versão da lib no git.
[] - Copiar libldsc-1.5 para Desenvolvimento-02-Bibliotecas-Releases/LIB_LDSC
[] - Gerar pacote com libldsc-1.5 + lvp e no nome adicionar Leandro.
Gerar a versão do lvp no git.
[] - Copiar lvp para Desenvolvimento-03-Programas-Releases.

[] - Criar hierarquia de classes/modelos para calcular distribuição de sítios e ligações a partir 
de imagens 2D.
[] - Criar hierarquia de classes/modelos para calcular distribuição de sítios e ligações a partir 
de imagens 3D.
[] - Criar hierarquia para montagem redes de percolação a partir distribuição de sítios e 
ligações.
[] - Criar estrutura para teste dos códigos desenvolvidos pelo Leandro. Deve adotar padrão uniforme 
em toda lib_ldsc.

[Específico mestrado Rafael]
=======================================
[] - Verificar códigos Rafael -2D e botar para funcionar (test/AberturaDilatacao).

[Específico mestrado Eneida]
=======================================
[] - Verificar códigos Eneida e botar para funcionar (test/RedesNeurais).

[Específico mestrado Tiago]
=======================================
[] - Verificar códigos DanoFormacao, mover para lib_ldsc.
[] - Verificar códigos SAIL,  adicionar ao LVP? 


\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
                     TODO-> Organizacao diretórios lib_ldsc
\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
[Nova estrutura diretórios]
=======================================
[bueno@localhost src]$ tree -L 3 -d
[x] - ├── Amostra
[x] - │   ├── AmostraRocha
[x] - │   └── Material
[x] - ├── AnaliseImagem
[x] - │   ├── Caracterizacao (geralmente uma informação geométrica)
[x] - │   │   ├── Correlacao
[x] - │   │   ├── Distribuicao
[x] - │   │   ├── Fractal
[x] - │   │   ├── GrafoConexaoSerial
[x] - │   │   └── RedePercolacao
[x] - │   ├── Filtro (criar namespace alias PreProcessamento)
[x] - │   │   ├── FAmplitude
[x] - │   │   ├── FEspacial
[x] - │   │   ├── FFrequencial
[x] - │   │   └── Mascara
[ ] - │   ├── Geometria (mover para dentro Caracterizacao)
[x] - │   │   └── Bola
[ ] - │   ├── Matriz (mover para MetNum)
[x] - │   ├── Reconstrucao
[x] - │   ├── Segmentacao
[x] - │   │   └── PorosGargantas
[x] - │   └── Simulacao (geralmente uma propriedade física)
[x] - │       ├── ConfiguracaoEquilibrio
[ ] - │       ├── Tortuosidade
[ ] - │       ├── DanoFormacao
[x] - │       └── Permeabilidade
[x] - ├── Base
[x] - ├── Estatistica
[x] - ├── Grafico
[x] - │   └── Gnuplot
[x] - ├── MetNum
[x] - │   ├── Contorno
[x] - │   ├── Funcao
[x] - │   ├── Integral
[x] - │   ├── Interpolacao
[x] - │   │   ├── Interpolacao2D
[x] - │   │   ├── IntMetNum
[x] - │   └── Solver
[x] - │       ├── Funcao
[x] - │       └── SistemaEquacoes
[ ] - ├── RedesNeurais
[x] - └── Tempo

[Nova estrutura diretórios 2 -> lib_ldsc(base) e lib_ldsc_engenharia]
======================================================================
Objetivo é separar o que é conceito básico,  que deve estar na lib_ldsc, 
de conceito derivado,  que deve estar numa biblioteca de aplicação.
Por exemplo,  programa pode precisar das coisas da lib_ldsc,  mas não do GrafoConexaoSerial ou ConfiguracaoEquilibrio.
-> lib_ldsc             (dividida em bibliotecas pequenas) 
[x] - ├── Base           (coisas muito básicas usadas com frequência em todos os lugares)
[x] - ├── EstruturaDados (dados em geral)
[x] - ├── AnaliseImagem  (livros gonzales/parker/russ/morfmat)
[x] - ├── Estatistica    (livros estatística e probabilidade)
[x] - ├── Grafico        (livros gráficos; acesso programas gráficos como gnuplot);
[ ] - ├── InteligenciaArtificial(livros redes neurais e inteligência artificial);
[x] - ├── MetNum         (livros métodos numéricos)

-> lib_ldsc_engenharia  (dividida em bibliotecas pequenas (+específico a engenharia))
[x] - ├── Materiais       (livros materiais)
[x] - ├── AnaliseImagem   (analise de imagem aplicada a engenharia,  livros engenharia)
-> Adicionar exemplos de provas
-> Adicionar códigos bismarck/wagner/capico
-> Adicionar códigos felipe schram
...

-> LVP                 Software
[x] - ├── XXX           ( software que usa as duas libs )

[bueno@localhost src]$ tree -L 3 -d
=======================================================================================lib_ldsc
-> lib_ldsc             (dividida em bibliotecas pequenas) 
[ ] - ├── Base        (coisas muito básicas usadas com frequência em todos os lugares)
[x] - │   ├── Tempo
[x] - ├── EstruturaDados (estruturas de dados em geral)
[x] - │   ├── Grafo     (conexões ) [CObjetoGrafo + CGrafo]
[x] - │   ├── Rede      (conexões + propriedades) [CObjetoRede + CRede]
[x] - │   ├── Esqueleto (conexões + propriedades + coordenada) [CObjetoEsqueleto + CEsqueleto]
[x] - ├── AnaliseImagem (encontrado livros gonzales/parker/russ/morfmat)
[ ] - │   ├── Base (coisas básicas usadas com frequência em analise de imagem)
[ ] - │   │   └── Geometria
[ ] - │   │   │   └── Bola
[ ] - │   │   └── Matriz (CVetor CMatriz2D CMatriz3D; em métodos numéricos usar array ou matriz de boost? )
[x] - │   ├── Filtro (realiza um PreProcessamento na imagem)
[x] - │   │   ├── FAmplitude 
[x] - │   │   ├── FEspacial
[x] - │   │   ├── FFrequencial
[x] - │   │   └── Mascara
[x] - ├── Estatistica (encontrado livros estatística e probabilidade)
[x] - │   ├── XX
[x] - │   │   └── XX
[x] - │   │   │   └── XX - classes programa alunos georgiana
[x] - ├── Grafico (encontrado livros gráficos; acesso programas gráficos como gnuplot);
[x] - │   └── Gnuplot
[ ] - ├── InteligenciaArtificial(encontrado livros redes neurais e inteligência artificial);
[x] - │   └── RedesNeurais codigos que montei (falta finalizar)
[x] - ├── MetNum       (encontrado livros métodos numéricos)
[x] - │   ├── Contorno
[x] - │   ├── Funcao
[x] - │   ├── Integral
[x] - │   ├── Interpolacao
[x] - │   │   ├── Interpolacao2D
[x] - │   │   ├── IntMetNum
[x] - │   └── Solver
[x] - │       ├── Funcao
[x] - │       └── SistemaEquacoes

=======================================================================================lib_ldsc_engenharia
-> lib_ldsc_engenharia  (dividida em bibliotecas pequenas (+específico a engenharia))
[x] - ├── Material
[x] - │   └── CFluido (criar hierarquia se for usar em nós de simulação)
[x] - │   └── CFluidoColetado (inclui dados coleta? )
[x] - │   └── Amostra
[x] - │   │   ├── DadosColeta   (informações sobre coleta da amostra ? ? ? quem/quando/onde..)
[x] - │   │   ├── AmostraRocha  (adiciona dados coleta)
[x] - ├── AnaliseImagem
[x] - │   ├── Base (coisas básicas usadas com frequência em analise de imagem de meios porosos)
[x] - │   ├── Filtro ( específicos segmentacao imagens meios porosos ? ? )
[x] - │   │   ├── FAmplitude 
[x] - │   ├── Caracterizacao (geralmente uma informação geométrica do meio poroso)
[x] - │   │   ├── Correlacao (função autocorrelação)
[x] - │   │   ├── Distribuicao ( distribuição tamanho poros - usar morfmat)
[x] - │   │   │   └── SitiosLigacoes (2D e 3D - Leandro)
[x] - │   │   │   └── PorosGargantas ***?
[x] - │   │   ├── GrafoConexaoSerial (tese Bueno)
[x] - │   │   └── RedePercolacao ( tese Leandro);
[x] - │   │   ├── Fractal (de meios porosos? )
[x] - │   ├── Reconstrucao (de meios porosos)
[x] - │   └── Simulacao (geralmente uma propriedade física)
[x] - │       ├── ConfiguracaoEquilibrio ***
[ ] - │       ├── Tortuosidade ***
[ ] - │       ├── DanoFormacao ***
[x] - │       └── Permeabilidade ***
[x] - ├── Estatistica
[x] - ├── Grafico
[x] - │   └── Gnuplot
[x] - ├── MetNum
[x] - │   ├── Contorno
[x] - │   ├── Funcao
[x] - │   ├── Integral
[x] - │   ├── Interpolacao
[x] - │   │   ├── Interpolacao2D
[x] - │   │   ├── IntMetNum
[x] - │   └── Solver
[x] - │       ├── Funcao
[x] - │       └── SistemaEquacoes
[ ] - ├── InteligenciaArtificial(encontrado livros redes neurais e inteligência artificial);
[ ] - │   └── RedesNeurais 
[x] - │       ├── AplicacaoX

\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
                    TODO: Documentacao lib_ldsc 
\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
Objetivo: revisar os códigos da biblioteca e ao mesmo tempo atualizar documentação.
[ ] - Documentar a lib_ldsc considerando inovações do doxygen, como exemplo: @todo @test @bug

\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
                    TODO: Conversão lib_ldsc para C++11
\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
Objetivo: Corrigir a lib_ldsc considerando inovações de C++11/C++14.
[] - Criar arquivo modelo que lista as inovações a serem consideradas (ver resumo c++11)
Para cada classe criar arquivo CNomeClasse.C++11.todo?
[ ] - Antes de fazer as modificacoes gerar saidas padrões, que devem ser posteriormente conferidas.
[ ] - Reescrever as classes básicas e depois os códigos específicos.
[ ] - Somente as classes novas devem fazer parte da nova lib?
[ ] - Reescrever CVetor/CMatriz2D/CMatriz3D usando template
[ ] - Reescrever CImagem2D/CImagem3D usando template
[ ] - Modificar CVetor CMatriz2D e CMatriz3D, de forma que a alocação seja da forma
double* pm1d =  new double[nx*ny*nz];
assim, códigos legados, como os herdados de Liang possam ser tratados sem o uso macros.
[ ] - Fazer correções conceituais e lógicas
[ ] - Estudar valarray e array,  objetivo entender como funcionam; e substituir CVetor CMatriz2D?  CMatriz3D?


\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
                    TODO: Pendências lib_ldsc 
\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
[Itens diversos recentes]
=======================================
[ ] -Renomear TFEEsqueletoV13D -> TFEEsqueleto_3D_M1  
[ ] -Renomear TFEEsqueletoV23D -> TFEEsqueleto_3D_M2  ...
[ ] -Eliminar CAberturaDilatacao-old
[ ] -Renomear CContornoCentro -> CEstimativaValorInicial
[ ] -Verificar possível relacao entre CDistribuicao e CDistribuicaoIDF
[ ] -Atualizar CENormal CEFStudent CEStudent CEChiQuadrado considerando classes específicas de C++11
(eventualmente devem ser eliminadas e substituidas no código pelas versões C++11).
[ ] -Substituir uso CERandomico por versão C++11
[ ] -relacao CEstatistica e CEstatistica2D
[ ] - CFuncoesEspeciais -> namespace CMath? usar/adicionar coisas de C++11
[ ] -CPermeabilidade -> CPermeabilidadeIntrinsica -> CPermeabilidadeRelativa
[ ] -CReconstrucaoEsferas herdeira de CReconstrucao?
[ ] -os diagramas gerados pelo doxygem poderiam ser apresentados considerando pacotes, pensar usar namespace ou pacotes do doxygen.
[ ] - CTime adicionar coisas de C++11
[ ] -Renomear CFEEsqueletoV1 -> CFEEsqueleto_M1

[Itens antigos]
=======================================
[] - Testar novas classes de Correlacao, ver resultado no lvp.
[] - A simulação da permeabilidade deve incluir ida e volta 
(ver código em src/coilib-imago/ConEq- TIConfiguracoesEquilibrio3D.h .cpp e 
TIConfEq3DSimPermRel.h .cpp).
[ ] - As provas feitas para os alunos tem exemplos que podem ser acrescentados a lib.
[ ] - Verificar quais trabalhos feitos por alunos tem códigos úteis. Fazer revisão.
[ ] - Implementar nova FFT (baseada no codigo do livro do parker).
[ ] - Testar calculo correlacao usando nova FFT?
[ ] - Testar reconstrucao usando nova FFT?
[ ] - Implementar classe derivada de CGrafo3Dby2D_M8 que usa idf para estimar as condutâncias!
Fazer análise comparativa do gráfico de poisele em tubo com gráfico idf usando diferentes métricas 
para identificar métrica que melhor estima poiselle.
[ ] - Implementar código híbrido, que calcula configurações de equilíbrio e a seguir usa lattice 
boltzman para ajuste fino. Acelerando calculo do lattice boltzman.


\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
                    TODO: Teste lib_ldsc 
\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
[ ] - O diretório test deve ter a mesma estrutura de src,
e cada subdiretório deve testar as classes correspondentes.
[ ] - Montar os testes com documentacao e dados completos, de forma que sejam úteis para usuários.
[ ] - O teste de Estatistica (Normal, student, ...) deve gerar os graficos usando o gnuplot.
[ ] - Os programas que foram colocados dentro de test devem ser retirados.
[ ] - Criar programa externo que acessa a lib. O programa deve ser bem documentado, de forma a 
servir de base para aprendizado.
[ ] - verificar IDF Euclidiana ; Esta utilizando valores maiores que 255, 
e está dando problema ao salvar a imagem tons de cinza em formato binário. 
(O formato binário utilizado pela libldsc é de 8 bits aceitando assim valores de 0 a 255). 


\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
                               TODO-> LVP
\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
[Específico LVP]
============================================
[ ] - Revisar códigos de Anaimp
[ ] - Revisar códigos de Imago
[ ] - Revisar códigos de SAIL
[ ] - Acrescentar códigos interesssantes de Anaimp
[ ] - Acrescentar códigos interesssantes de Imago
[ ] - Acrescentar códigos interesssantes de SAIL

Tempo compilação:
==================

Teste 1: sem cache, tudo zerado
make -j 1

make -j 4

Teste 2: com cache
time make 
  real	0m13.669s
  user	0m8.117s
  sys	0m4.529s

make -j 4
  real	0m5.118s
  user	0m6.806s
  sys	0m3.984s


\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
TODO-> Comparativo: autotools x cmake x ninja x scons
\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

  An important distinction must be made between who uses the tools. 
  Cmake is a tool that must be used by the user when building the software. 
  The autotools are used to generate a distribution tarball that can be used to build the 
  software using only the standard tools available on any SuS compliant system. In other words, 
  if you are installing software from a tarball that was built using the autotools, 
  you are not using the autotools. On the other hand, if you are installing software that uses Cmake, 
  then you are using Cmake and must have it installed to build the software.
  
  The great majority of users do not need to have the autotools installed on their box. 
  Historically, much confusion has been caused because many developers distribute 
  malformed tarballs that force the user to run autoconf to regenerate the configure script,
  and this is a packaging error. More confusion has been caused by the fact that most 
  major linux distributions install multiple versions of the autotools, when they should not
  be installing any of them by default. Even more confusion is caused by developers attempting
  to use a version control system (eg cvs, git, svn) to distribute their software rather than 
  building tarballs.
  
  
